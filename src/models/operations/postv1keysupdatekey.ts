/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { z } from "zod";

/**
 * Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
 *
 * @see {@link https://unkey.dev/docs/features/ratelimiting} - Learn more
 */
export enum PostV1KeysUpdateKeyType {
    Fast = "fast",
    Consistent = "consistent",
}

/**
 * Unkey comes with per-key ratelimiting out of the box. Set `null` to disable.
 */
export type PostV1KeysUpdateKeyRatelimit = {
    /**
     * Fast ratelimiting doesn't add latency, while consistent ratelimiting is more accurate.
     */
    type: PostV1KeysUpdateKeyType;
    /**
     * The total amount of burstable requests.
     */
    limit: number;
    /**
     * How many tokens to refill during each refillInterval.
     */
    refillRate: number;
    /**
     * Determines the speed at which tokens are refilled, in milliseconds.
     */
    refillInterval: number;
};

/**
 * Unkey will automatically refill verifications at the set interval. If null is used the refill functionality will be removed from the key.
 */
export enum PostV1KeysUpdateKeyInterval {
    Daily = "daily",
    Monthly = "monthly",
}

/**
 * Unkey enables you to refill verifications for each key at regular intervals.
 */
export type PostV1KeysUpdateKeyRefill = {
    /**
     * Unkey will automatically refill verifications at the set interval. If null is used the refill functionality will be removed from the key.
     */
    interval: PostV1KeysUpdateKeyInterval;
    /**
     * The amount of verifications to refill for each occurrence is determined individually for each key.
     */
    amount: number;
};

export type PostV1KeysUpdateKeyRequestBody = {
    /**
     * The id of the key you want to modify
     */
    keyId: string;
    /**
     * The name of the key
     */
    name?: string | null | undefined;
    /**
     * The id of the tenant associated with this key. Use whatever reference you have in your system to identify the tenant. When verifying the key, we will send this field back to you, so you know who is accessing your API.
     */
    ownerId?: string | null | undefined;
    /**
     * Any additional metadata you want to store with the key
     */
    meta?: Record<string, any> | null | undefined;
    /**
     * The unix timestamp in milliseconds when the key will expire. If this field is null or undefined, the key is not expiring.
     */
    expires?: number | null | undefined;
    /**
     * Unkey comes with per-key ratelimiting out of the box. Set `null` to disable.
     */
    ratelimit?: PostV1KeysUpdateKeyRatelimit | null | undefined;
    /**
     * The number of requests that can be made with this key before it becomes invalid. Set `null` to disable.
     */
    remaining?: number | null | undefined;
    /**
     * Unkey enables you to refill verifications for each key at regular intervals.
     */
    refill?: PostV1KeysUpdateKeyRefill | null | undefined;
    /**
     * Set if key is enabled or disabled. If disabled, the key cannot be used to verify.
     */
    enabled?: boolean | undefined;
};

/**
 * The key was successfully updated, it may take up to 30s for this to take effect in all regions
 */
export type PostV1KeysUpdateKeyResponseBody = {};

export type PostV1KeysUpdateKeyResponse = {
    /**
     * HTTP response content type for this operation
     */
    contentType: string;
    /**
     * HTTP response status code for this operation
     */
    statusCode: number;
    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    rawResponse: Response;
    /**
     * The key was successfully updated, it may take up to 30s for this to take effect in all regions
     */
    object?: PostV1KeysUpdateKeyResponseBody | undefined;
};

/** @internal */
export const PostV1KeysUpdateKeyType$ = z.nativeEnum(PostV1KeysUpdateKeyType);

/** @internal */
export namespace PostV1KeysUpdateKeyRatelimit$ {
    export type Inbound = {
        type: PostV1KeysUpdateKeyType;
        limit: number;
        refillRate: number;
        refillInterval: number;
    };

    export const inboundSchema: z.ZodType<PostV1KeysUpdateKeyRatelimit, z.ZodTypeDef, Inbound> = z
        .object({
            type: PostV1KeysUpdateKeyType$,
            limit: z.number().int(),
            refillRate: z.number().int(),
            refillInterval: z.number().int(),
        })
        .transform((v) => {
            return {
                type: v.type,
                limit: v.limit,
                refillRate: v.refillRate,
                refillInterval: v.refillInterval,
            };
        });

    export type Outbound = {
        type: PostV1KeysUpdateKeyType;
        limit: number;
        refillRate: number;
        refillInterval: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysUpdateKeyRatelimit> = z
        .object({
            type: PostV1KeysUpdateKeyType$,
            limit: z.number().int(),
            refillRate: z.number().int(),
            refillInterval: z.number().int(),
        })
        .transform((v) => {
            return {
                type: v.type,
                limit: v.limit,
                refillRate: v.refillRate,
                refillInterval: v.refillInterval,
            };
        });
}

/** @internal */
export const PostV1KeysUpdateKeyInterval$ = z.nativeEnum(PostV1KeysUpdateKeyInterval);

/** @internal */
export namespace PostV1KeysUpdateKeyRefill$ {
    export type Inbound = {
        interval: PostV1KeysUpdateKeyInterval;
        amount: number;
    };

    export const inboundSchema: z.ZodType<PostV1KeysUpdateKeyRefill, z.ZodTypeDef, Inbound> = z
        .object({
            interval: PostV1KeysUpdateKeyInterval$,
            amount: z.number().int(),
        })
        .transform((v) => {
            return {
                interval: v.interval,
                amount: v.amount,
            };
        });

    export type Outbound = {
        interval: PostV1KeysUpdateKeyInterval;
        amount: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysUpdateKeyRefill> = z
        .object({
            interval: PostV1KeysUpdateKeyInterval$,
            amount: z.number().int(),
        })
        .transform((v) => {
            return {
                interval: v.interval,
                amount: v.amount,
            };
        });
}

/** @internal */
export namespace PostV1KeysUpdateKeyRequestBody$ {
    export type Inbound = {
        keyId: string;
        name?: string | null | undefined;
        ownerId?: string | null | undefined;
        meta?: Record<string, any> | null | undefined;
        expires?: number | null | undefined;
        ratelimit?: PostV1KeysUpdateKeyRatelimit$.Inbound | null | undefined;
        remaining?: number | null | undefined;
        refill?: PostV1KeysUpdateKeyRefill$.Inbound | null | undefined;
        enabled?: boolean | undefined;
    };

    export const inboundSchema: z.ZodType<PostV1KeysUpdateKeyRequestBody, z.ZodTypeDef, Inbound> = z
        .object({
            keyId: z.string(),
            name: z.nullable(z.string()).optional(),
            ownerId: z.nullable(z.string()).optional(),
            meta: z.nullable(z.record(z.any())).optional(),
            expires: z.nullable(z.number()).optional(),
            ratelimit: z
                .nullable(z.lazy(() => PostV1KeysUpdateKeyRatelimit$.inboundSchema))
                .optional(),
            remaining: z.nullable(z.number()).optional(),
            refill: z.nullable(z.lazy(() => PostV1KeysUpdateKeyRefill$.inboundSchema)).optional(),
            enabled: z.boolean().optional(),
        })
        .transform((v) => {
            return {
                keyId: v.keyId,
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.ownerId === undefined ? null : { ownerId: v.ownerId }),
                ...(v.meta === undefined ? null : { meta: v.meta }),
                ...(v.expires === undefined ? null : { expires: v.expires }),
                ...(v.ratelimit === undefined ? null : { ratelimit: v.ratelimit }),
                ...(v.remaining === undefined ? null : { remaining: v.remaining }),
                ...(v.refill === undefined ? null : { refill: v.refill }),
                ...(v.enabled === undefined ? null : { enabled: v.enabled }),
            };
        });

    export type Outbound = {
        keyId: string;
        name?: string | null | undefined;
        ownerId?: string | null | undefined;
        meta?: Record<string, any> | null | undefined;
        expires?: number | null | undefined;
        ratelimit?: PostV1KeysUpdateKeyRatelimit$.Outbound | null | undefined;
        remaining?: number | null | undefined;
        refill?: PostV1KeysUpdateKeyRefill$.Outbound | null | undefined;
        enabled?: boolean | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysUpdateKeyRequestBody> =
        z
            .object({
                keyId: z.string(),
                name: z.nullable(z.string()).optional(),
                ownerId: z.nullable(z.string()).optional(),
                meta: z.nullable(z.record(z.any())).optional(),
                expires: z.nullable(z.number()).optional(),
                ratelimit: z
                    .nullable(z.lazy(() => PostV1KeysUpdateKeyRatelimit$.outboundSchema))
                    .optional(),
                remaining: z.nullable(z.number()).optional(),
                refill: z
                    .nullable(z.lazy(() => PostV1KeysUpdateKeyRefill$.outboundSchema))
                    .optional(),
                enabled: z.boolean().optional(),
            })
            .transform((v) => {
                return {
                    keyId: v.keyId,
                    ...(v.name === undefined ? null : { name: v.name }),
                    ...(v.ownerId === undefined ? null : { ownerId: v.ownerId }),
                    ...(v.meta === undefined ? null : { meta: v.meta }),
                    ...(v.expires === undefined ? null : { expires: v.expires }),
                    ...(v.ratelimit === undefined ? null : { ratelimit: v.ratelimit }),
                    ...(v.remaining === undefined ? null : { remaining: v.remaining }),
                    ...(v.refill === undefined ? null : { refill: v.refill }),
                    ...(v.enabled === undefined ? null : { enabled: v.enabled }),
                };
            });
}

/** @internal */
export namespace PostV1KeysUpdateKeyResponseBody$ {
    export type Inbound = {};

    export const inboundSchema: z.ZodType<PostV1KeysUpdateKeyResponseBody, z.ZodTypeDef, Inbound> =
        z.object({});

    export type Outbound = {};

    export const outboundSchema: z.ZodType<
        Outbound,
        z.ZodTypeDef,
        PostV1KeysUpdateKeyResponseBody
    > = z.object({});
}

/** @internal */
export namespace PostV1KeysUpdateKeyResponse$ {
    export type Inbound = {
        ContentType: string;
        StatusCode: number;
        RawResponse: Response;
        object?: PostV1KeysUpdateKeyResponseBody$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<PostV1KeysUpdateKeyResponse, z.ZodTypeDef, Inbound> = z
        .object({
            ContentType: z.string(),
            StatusCode: z.number().int(),
            RawResponse: z.instanceof(Response),
            object: z.lazy(() => PostV1KeysUpdateKeyResponseBody$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                contentType: v.ContentType,
                statusCode: v.StatusCode,
                rawResponse: v.RawResponse,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });

    export type Outbound = {
        ContentType: string;
        StatusCode: number;
        RawResponse: never;
        object?: PostV1KeysUpdateKeyResponseBody$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysUpdateKeyResponse> = z
        .object({
            contentType: z.string(),
            statusCode: z.number().int(),
            rawResponse: z.instanceof(Response).transform(() => {
                throw new Error("Response cannot be serialized");
            }),
            object: z.lazy(() => PostV1KeysUpdateKeyResponseBody$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ContentType: v.contentType,
                StatusCode: v.statusCode,
                RawResponse: v.rawResponse,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });
}

/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as z from "zod";

export type PostV1KeysVerifyRequestBody = {
    /**
     * The id of the api where the key belongs to. This is optional for now but will be required soon.
     *
     * @remarks
     * The key will be verified against the api's configuration. If the key does not belong to the api, the verification will fail.
     */
    apiId?: string | undefined;
    /**
     * The key to verify
     */
    key: string;
};

/**
 * The ratelimit configuration for this key. If this field is null or undefined, the key has no ratelimit.
 */
export type PostV1KeysVerifyRatelimit = {
    /**
     * Maximum number of requests that can be made inside a window
     */
    limit: number;
    /**
     * Remaining requests after this verification
     */
    remaining: number;
    /**
     * Unix timestamp in milliseconds when the ratelimit will reset
     */
    reset: number;
};

/**
 * If the key is invalid this field will be set to the reason why it is invalid.
 *
 * @remarks
 * Possible values are:
 * - NOT_FOUND: the key does not exist or has expired
 * - FORBIDDEN: the key is not allowed to access the api
 * - USAGE_EXCEEDED: the key has exceeded its request limit
 * - RATE_LIMITED: the key has been ratelimited,
 *
 */
export enum PostV1KeysVerifyCode {
    NotFound = "NOT_FOUND",
    Forbidden = "FORBIDDEN",
    UsageExceeded = "USAGE_EXCEEDED",
    RateLimited = "RATE_LIMITED",
    Unauthorized = "UNAUTHORIZED",
    Disabled = "DISABLED",
}

/**
 * The verification result
 */
export type PostV1KeysVerifyResponseBody = {
    /**
     * The id of the key
     */
    keyId?: string | undefined;
    /**
     * Whether the key is valid or not.
     *
     * @remarks
     * A key could be invalid for a number of reasons, for example if it has expired, has no more verifications left or if it has been deleted.
     */
    valid: boolean;
    /**
     * The name of the key, give keys a name to easily identifiy their purpose
     */
    name?: string | undefined;
    /**
     * The id of the tenant associated with this key. Use whatever reference you have in your system to identify the tenant. When verifying the key, we will send this field back to you, so you know who is accessing your API.
     */
    ownerId?: string | undefined;
    /**
     * Any additional metadata you want to store with the key
     */
    meta?: Record<string, any> | undefined;
    /**
     * The unix timestamp in milliseconds when the key was created
     */
    createdAt?: number | undefined;
    /**
     * The unix timestamp in milliseconds when the key was deleted. We don't delete the key outright, you can restore it later.
     */
    deletedAt?: number | undefined;
    /**
     * The unix timestamp in milliseconds when the key will expire. If this field is null or undefined, the key is not expiring.
     */
    expires?: number | undefined;
    /**
     * The ratelimit configuration for this key. If this field is null or undefined, the key has no ratelimit.
     */
    ratelimit?: PostV1KeysVerifyRatelimit | undefined;
    /**
     * The number of requests that can be made with this key before it becomes invalid. If this field is null or undefined, the key has no request limit.
     */
    remaining?: number | undefined;
    /**
     * If the key is invalid this field will be set to the reason why it is invalid.
     *
     * @remarks
     * Possible values are:
     * - NOT_FOUND: the key does not exist or has expired
     * - FORBIDDEN: the key is not allowed to access the api
     * - USAGE_EXCEEDED: the key has exceeded its request limit
     * - RATE_LIMITED: the key has been ratelimited,
     *
     */
    code?: PostV1KeysVerifyCode | undefined;
};

export type PostV1KeysVerifyResponse = {
    /**
     * HTTP response content type for this operation
     */
    contentType: string;
    /**
     * HTTP response status code for this operation
     */
    statusCode: number;
    /**
     * Raw HTTP response; suitable for custom response parsing
     */
    rawResponse: Response;
    /**
     * The verification result
     */
    object?: PostV1KeysVerifyResponseBody | undefined;
};

/** @internal */
export namespace PostV1KeysVerifyRequestBody$ {
    export type Inbound = {
        apiId?: string | undefined;
        key: string;
    };

    export const inboundSchema: z.ZodType<PostV1KeysVerifyRequestBody, z.ZodTypeDef, Inbound> = z
        .object({
            apiId: z.string().optional(),
            key: z.string(),
        })
        .transform((v) => {
            return {
                ...(v.apiId === undefined ? null : { apiId: v.apiId }),
                key: v.key,
            };
        });

    export type Outbound = {
        apiId?: string | undefined;
        key: string;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysVerifyRequestBody> = z
        .object({
            apiId: z.string().optional(),
            key: z.string(),
        })
        .transform((v) => {
            return {
                ...(v.apiId === undefined ? null : { apiId: v.apiId }),
                key: v.key,
            };
        });
}

/** @internal */
export namespace PostV1KeysVerifyRatelimit$ {
    export type Inbound = {
        limit: number;
        remaining: number;
        reset: number;
    };

    export const inboundSchema: z.ZodType<PostV1KeysVerifyRatelimit, z.ZodTypeDef, Inbound> = z
        .object({
            limit: z.number(),
            remaining: z.number(),
            reset: z.number(),
        })
        .transform((v) => {
            return {
                limit: v.limit,
                remaining: v.remaining,
                reset: v.reset,
            };
        });

    export type Outbound = {
        limit: number;
        remaining: number;
        reset: number;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysVerifyRatelimit> = z
        .object({
            limit: z.number(),
            remaining: z.number(),
            reset: z.number(),
        })
        .transform((v) => {
            return {
                limit: v.limit,
                remaining: v.remaining,
                reset: v.reset,
            };
        });
}

/** @internal */
export const PostV1KeysVerifyCode$ = z.nativeEnum(PostV1KeysVerifyCode);

/** @internal */
export namespace PostV1KeysVerifyResponseBody$ {
    export type Inbound = {
        keyId?: string | undefined;
        valid: boolean;
        name?: string | undefined;
        ownerId?: string | undefined;
        meta?: Record<string, any> | undefined;
        createdAt?: number | undefined;
        deletedAt?: number | undefined;
        expires?: number | undefined;
        ratelimit?: PostV1KeysVerifyRatelimit$.Inbound | undefined;
        remaining?: number | undefined;
        code?: PostV1KeysVerifyCode | undefined;
    };

    export const inboundSchema: z.ZodType<PostV1KeysVerifyResponseBody, z.ZodTypeDef, Inbound> = z
        .object({
            keyId: z.string().optional(),
            valid: z.boolean(),
            name: z.string().optional(),
            ownerId: z.string().optional(),
            meta: z.record(z.any()).optional(),
            createdAt: z.number().optional(),
            deletedAt: z.number().optional(),
            expires: z.number().optional(),
            ratelimit: z.lazy(() => PostV1KeysVerifyRatelimit$.inboundSchema).optional(),
            remaining: z.number().optional(),
            code: PostV1KeysVerifyCode$.optional(),
        })
        .transform((v) => {
            return {
                ...(v.keyId === undefined ? null : { keyId: v.keyId }),
                valid: v.valid,
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.ownerId === undefined ? null : { ownerId: v.ownerId }),
                ...(v.meta === undefined ? null : { meta: v.meta }),
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.deletedAt === undefined ? null : { deletedAt: v.deletedAt }),
                ...(v.expires === undefined ? null : { expires: v.expires }),
                ...(v.ratelimit === undefined ? null : { ratelimit: v.ratelimit }),
                ...(v.remaining === undefined ? null : { remaining: v.remaining }),
                ...(v.code === undefined ? null : { code: v.code }),
            };
        });

    export type Outbound = {
        keyId?: string | undefined;
        valid: boolean;
        name?: string | undefined;
        ownerId?: string | undefined;
        meta?: Record<string, any> | undefined;
        createdAt?: number | undefined;
        deletedAt?: number | undefined;
        expires?: number | undefined;
        ratelimit?: PostV1KeysVerifyRatelimit$.Outbound | undefined;
        remaining?: number | undefined;
        code?: PostV1KeysVerifyCode | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysVerifyResponseBody> = z
        .object({
            keyId: z.string().optional(),
            valid: z.boolean(),
            name: z.string().optional(),
            ownerId: z.string().optional(),
            meta: z.record(z.any()).optional(),
            createdAt: z.number().optional(),
            deletedAt: z.number().optional(),
            expires: z.number().optional(),
            ratelimit: z.lazy(() => PostV1KeysVerifyRatelimit$.outboundSchema).optional(),
            remaining: z.number().optional(),
            code: PostV1KeysVerifyCode$.optional(),
        })
        .transform((v) => {
            return {
                ...(v.keyId === undefined ? null : { keyId: v.keyId }),
                valid: v.valid,
                ...(v.name === undefined ? null : { name: v.name }),
                ...(v.ownerId === undefined ? null : { ownerId: v.ownerId }),
                ...(v.meta === undefined ? null : { meta: v.meta }),
                ...(v.createdAt === undefined ? null : { createdAt: v.createdAt }),
                ...(v.deletedAt === undefined ? null : { deletedAt: v.deletedAt }),
                ...(v.expires === undefined ? null : { expires: v.expires }),
                ...(v.ratelimit === undefined ? null : { ratelimit: v.ratelimit }),
                ...(v.remaining === undefined ? null : { remaining: v.remaining }),
                ...(v.code === undefined ? null : { code: v.code }),
            };
        });
}

/** @internal */
export namespace PostV1KeysVerifyResponse$ {
    export type Inbound = {
        ContentType: string;
        StatusCode: number;
        RawResponse: Response;
        object?: PostV1KeysVerifyResponseBody$.Inbound | undefined;
    };

    export const inboundSchema: z.ZodType<PostV1KeysVerifyResponse, z.ZodTypeDef, Inbound> = z
        .object({
            ContentType: z.string(),
            StatusCode: z.number().int(),
            RawResponse: z.instanceof(Response),
            object: z.lazy(() => PostV1KeysVerifyResponseBody$.inboundSchema).optional(),
        })
        .transform((v) => {
            return {
                contentType: v.ContentType,
                statusCode: v.StatusCode,
                rawResponse: v.RawResponse,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });

    export type Outbound = {
        ContentType: string;
        StatusCode: number;
        RawResponse: never;
        object?: PostV1KeysVerifyResponseBody$.Outbound | undefined;
    };

    export const outboundSchema: z.ZodType<Outbound, z.ZodTypeDef, PostV1KeysVerifyResponse> = z
        .object({
            contentType: z.string(),
            statusCode: z.number().int(),
            rawResponse: z.instanceof(Response).transform(() => {
                throw new Error("Response cannot be serialized");
            }),
            object: z.lazy(() => PostV1KeysVerifyResponseBody$.outboundSchema).optional(),
        })
        .transform((v) => {
            return {
                ContentType: v.contentType,
                StatusCode: v.statusCode,
                RawResponse: v.rawResponse,
                ...(v.object === undefined ? null : { object: v.object }),
            };
        });
}
